<script setup lang="ts">
/**
 * Admin 表单组件（使用 formApi）
 * 
 * @description
 * 高级表单组件，通过 formApi 提供完整的表单控制能力。
 * 支持表单值变化监听、回车提交、自动提交等高级功能。
 * 适用于需要编程式控制表单的复杂场景。
 * 
 * @example
 * ```vue
 * <script setup>
 * const [Form, formApi] = useAdminForm({
 *   schema: formSchema,
 *   handleSubmit: onSubmit
 * });
 * </script>
 * 
 * <template>
 *   <Form />
 * </template>
 * ```
 */
import type { Recordable } from '@admin-core/shared/types';

import type { ExtendedFormApi, AdminFormProps } from './types';

import { nextTick, onMounted, watch } from 'vue';

import { useForwardPriorityValues } from '@admin-core/composables';
import { cloneDeep, get, isEqual, set } from '@admin-core/shared/utils';

import { useDebounceFn } from '@vueuse/core';

import FormActions from './components/form-actions.vue';
import {
  COMPONENT_BIND_EVENT_MAP,
  COMPONENT_MAP,
  DEFAULT_FORM_COMMON_CONFIG,
} from './config';
import { Form } from './form-render';
import {
  provideComponentRefMap,
  provideFormProps,
  useFormInitial,
} from './use-form-context';
// 通过 extends 会导致热更新卡死，所以重复写了一遍
interface Props extends AdminFormProps {
  formApi?: ExtendedFormApi;
}

const props = defineProps<Props>();

/** 从 formApi 获取响应式状态 */
const state = props.formApi?.useStore?.();

/** 合并 props 和 state，state 优先级更高 */
const forward = useForwardPriorityValues(props, state);

/** 组件引用映射表，用于存储表单字段的组件实例 */
const componentRefMap = new Map<string, unknown>();

/** 初始化表单和插槽 */
const { delegatedSlots, form } = useFormInitial(forward as any);

/** 提供表单属性和组件引用映射给子组件 */
provideFormProps([forward as any, form]);
provideComponentRefMap(componentRefMap);

/** 挂载表单 API */
props.formApi?.mount?.(form, componentRefMap);

/**
 * 处理折叠状态更新
 * 
 * @param value - 新的折叠状态
 */
const handleUpdateCollapsed = (value: boolean) => {
  props.formApi?.setState({ collapsed: value });
  // 触发收起展开状态变化回调
  forward.value.handleCollapsedChange?.(value);
};

/**
 * 处理回车键提交
 * 
 * @description
 * 当启用 submitOnEnter 时，按下回车键会触发表单提交。
 * textarea 元素除外，以保留换行功能。
 * 
 * @param event - 键盘事件
 */
function handleKeyDownEnter(event: KeyboardEvent) {
  if (!state?.value.submitOnEnter || !forward.value.formApi?.isMounted) {
    return;
  }
  // 如果是 textarea 不阻止默认行为，否则会导致无法换行。
  // 跳过 textarea 的回车提交处理
  if (event.target instanceof HTMLTextAreaElement) {
    return;
  }
  event.preventDefault();

  forward.value.formApi?.validateAndSubmitForm();
}

/**
 * 防抖处理表单值变化时的自动提交
 * 
 * @description
 * 当启用 submitOnChange 时，表单值变化会触发自动提交，
 * 使用防抖避免频繁提交
 */
const handleValuesChangeDebounced = useDebounceFn(async () => {
  state?.value.submitOnChange && forward.value.formApi?.validateAndSubmitForm();
}, 300);

/** 表单值缓存，用于检测变化的字段 */
const valuesCache: Recordable<any> = {};

/**
 * 组件挂载后监听表单值变化
 * 
 * @description
 * 监听表单值的变化，识别具体变化的字段，
 * 并触发 handleValuesChange 回调和自动提交逻辑
 */
onMounted(async () => {
  // 只在挂载后开始监听，form.values 会有一个初始化的过程
  await nextTick();
  
  watch(
    () => form.values,
    async (newVal) => {
      if (!forward.value.handleValuesChange) return;
      
      const fields = state?.value.schema?.map((item) => item.fieldName);
      if (!fields?.length) return;

      const changedFields = fields.filter((field) => {
        const newFieldValue = get(newVal, field);
        const oldFieldValue = get(valuesCache, field);
        
        if (!isEqual(newFieldValue, oldFieldValue)) {
          set(valuesCache, field, newFieldValue);
          return true;
        }
        return false;
      });

      if (changedFields.length > 0) {
        // 调用 handleValuesChange 回调，传入所有表单值的深拷贝和变更的字段列表
        const values = await forward.value.formApi?.getValues();
        forward.value.handleValuesChange(
          cloneDeep(values ?? {}) as Record<string, any>,
          changedFields,
        );
      }
      
      handleValuesChangeDebounced();
    },
    { deep: true },
  );
});
</script>

<template>
  <Form
    @keydown.enter="handleKeyDownEnter"
    v-bind="forward as any"
    :collapsed="state?.collapsed"
    :component-bind-event-map="COMPONENT_BIND_EVENT_MAP"
    :component-map="COMPONENT_MAP"
    :form="form"
    :global-common-config="DEFAULT_FORM_COMMON_CONFIG"
  >
    <template
      v-for="slotName in delegatedSlots"
      :key="slotName"
      #[slotName]="slotProps"
    >
      <slot :name="slotName" v-bind="slotProps"></slot>
    </template>
    <template #default="slotProps">
      <slot v-bind="slotProps">
        <FormActions
          v-if="forward.showDefaultActions"
          :model-value="state?.collapsed ?? false"
          @update:model-value="handleUpdateCollapsed"
        >
          <template #reset-before="resetSlotProps">
            <slot name="reset-before" v-bind="resetSlotProps"></slot>
          </template>
          <template #submit-before="submitSlotProps">
            <slot name="submit-before" v-bind="submitSlotProps"></slot>
          </template>
          <template #expand-before="expandBeforeSlotProps">
            <slot name="expand-before" v-bind="expandBeforeSlotProps"></slot>
          </template>
          <template #expand-after="expandAfterSlotProps">
            <slot name="expand-after" v-bind="expandAfterSlotProps"></slot>
          </template>
        </FormActions>
      </slot>
    </template>
  </Form>
</template>
